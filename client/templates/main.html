<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>MLCraft</title>
    <meta name="description" content="none yet" />
    <script src="../scripts/storage.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"
      integrity="sha256-KzZiKy0DWYsnwMF+X1DvQngQ2/FxF7MF3Ff72XcpuPs="
      crossorigin="anonymous"
    ></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css" />
    <link rel="stylesheet" type="text/css" href="../styles/style.css" />
    <link rel="stylesheet" type="text/css" href="../styles/palette.css" />
    <link rel="stylesheet" type="text/css" href="../styles/day_night_mode.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
      integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ="
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@9"></script>
    <script src="https://unpkg.com/micromodal/dist/micromodal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.13.0/Sortable.min.js"></script>
    <script src="../scripts/day_night_mode.js"></script>
    <script src="../scripts/requests.js"></script>
  </head>
  <body>
    <!-- HTML parts -->
    <header>
      <label class="button-wrapper">
        <input type="button" class="profile-check" onclick="showProfile()" />
        <i
          class="material-icons"
          style="font-size: 65px; position: relative; left: -7px; bottom: 2px"
          onmousedown="return false"
          >person</i
        >
      </label>
      <h2 onmousedown="return false">MLCraft</h2>
      <div class="github-link">
        <a href="https://github.com/SPbuMinecraft/GraphicalEditorForNN" target="_blank"
          ><i class="fab fa-github fa-3x" style="color: var(--background3)"></i
        ></a>
      </div>
      <div class="menu" onmousedown="return false">
        <ul>
          <li id="select-home" onclick="showMode(event);">Home</li>
          <li id="select-constructor" onclick="showMode(event);" class="selected">Constructor</li>
          <li id="select-terminal" onclick="showMode(event);">Terminal</li>
          <li id="select-metrics" onclick="showMode(event);">Metrics</li>
        </ul>
      </div>
    </header>

    <div class="profile" id="profile">
      <a style="text-decoration: none" href="../index.html" onclick="signOut()">
        <input class="button-wrapper" type="button" id="sing-out-button" value="Sign out" />
      </a>
      <label class="day-night-mode-label">
        <input
          type="checkbox"
          id="day-night-checkbox-id"
          class="day-night-checkbox"
          value="day"
          onclick="changeTheme()"
        />
        <span class="control"></span>
      </label>
    </div>

    <div class="home" id="home">
      <div class="background">
        <div class="nn-container-class" id="nn-container"></div>
        <div class="nn-block" id="new-nn">
          <label class="button-wrapper">
            Create
            <input type="button" onclick="createNewNN()" /> </label
          ><br />
          <label class="button-wrapper">
            Upload
            <input type="file" id="onnx-upload-button" accept=".onnx" oninput="uploadModel()" />
          </label>
        </div>
      </div>
    </div>
    <!--Меню выбора блоков  -->
    <div class="constructor" id="constructor">
      <div class="col">
        <br />
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `linear`)" data-node="linear">
          <span> Linear</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `relu`)" data-node="relu">
          <span> ReLU</span>
        </div>

        <!--
    <div
            class="drag-drawflow"
            draggable="true"
            ondragstart="drag(event)"
            data-node="sigmoid">
        <span> Sigmoid</span>

    </div>
    -->
        <div class="drag-drawflow" draggable="false" onmousedown="return false">
          <span> Coming soon</span>
        </div>
        <br />

        <label class="button-wrapper">
          Upload
          <input type="file" id="csv-upload-button" accept=".csv" />
        </label>

        <label class="button-wrapper" id="train-button" disabled>
          Train
          <input type="button" onclick="trainRequest()" disabled />
        </label>

        <label class="button-wrapper" disabled>
          Predict
          <input type="file" accept=".csv" id="csv-predict-button" disabled />
        </label>
        <div class="predict-result-wrapper" id="predict-result-wrapper">
          <output class="form-control-res" id="res-value-out" name="res-value" for="x-value y-value"></output>
        </div>
      </div>

      <div class="col-right">
        <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)">
          <div class="btn-save" onclick="save()">Save</div>
          <div class="btn-clear" onclick="editor.clear()">Clear</div>
          <div class="btn-lock">
            <i id="lock" class="fas fa-lock" onclick="editor.editor_mode='fixed'; changeMode('lock');"></i>
            <i
              id="unlock"
              class="fas fa-lock-open"
              onclick="editor.editor_mode='edit'; changeMode('unlock');"
              style="display: none"
            ></i>
          </div>
          <div class="bar-zoom">
            <i class="fas fa-search-minus" onclick="editor.zoom_out()"></i>
            <i class="fas fa-search" onclick="editor.zoom_reset()"></i>
            <i class="fas fa-search-plus" onclick="editor.zoom_in()"></i>
          </div>
        </div>
      </div>

      <div class="layer-data" id="layer-data">
        <h2>Layer parameters</h2>
        <label id="layer-id"></label>
        <h3></h3>
        <div class="linear-layer-parameters layer-parameters" id="linear-layer-parameters" style="display: none">
          <label for="bias-parameter">Bias</label>
          <select id="bias-parameter">
            <option value="true">true</option>
            <option value="false">false</option>
          </select>
          <h3></h3>
          <label for="linear-inFeatures-parameter">inFeatures</label>
          <input id="linear-inFeatures-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <label for="linear-outFeatures-parameter"> outFeatures </label>
          <input id="linear-outFeatures-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="linear-input-selection">
            <label class="layer-input-list" style="display: none"> Input order: </label>
            <ul id="linear-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="relu-layer-parameters layer-parameters" id="relu-layer-parameters" style="display: none">
          <div id="relu-input-selection">
            <label class="layer-input-list" style="display: none">Input order: </label>
            <ul id="relu-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="special-layer-parameters layer-parameters" id="special-layer-parameters" style="display: none">
          <label for="special-width-parameter">Width</label>
          <input id="special-width-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="special-input-selection">
            <label class="layer-input-list" style="display: none"> Input order: </label>
            <ul id="special-inputs-sortable-list"></ul>
          </div>
        </div>
      </div>
    </div>

    <div class="terminal" id="terminal">Coming soon!</div>

    <div class="metrics" id="metrics">Coming soon!</div>

    <!--Работа с Drawflow-->
    <script>
      function saveCanvasToLocalStorage(editorObj) {
        // Переводим объект в строку JSON

        let jsonString = JSON.stringify(editorObj.export())
        // Сохраняем строку в LocalStorage с определенным ключом
        localStorage.setItem("canvas", jsonString)
      }

      function setCanvasFromLocalStorage(editorObj) {
        // Получаем строку из LocalStorage по ключу
        const jsonString = localStorage.getItem("canvas")
        // Если строка не пуста, преобразуем её в объект
        if (jsonString) {
          let json = JSON.parse(jsonString)
          editorObj.import(json, notifi=false)
          return json
        } else {
          // Если строка пуста (ключ отсутствует или значение null), возвращаем null или другое значение по умолчанию
          return null
        }
      }

      class CustomDrawflow extends Drawflow {
        constructor(id) {
          super(id)
        }
        removeNodeId(id) {
          let nodeClassFromId = this.getNodeFromId(id.slice(5)).class
          if (nodeClassFromId === "special") {
            return
          }
          const layer_dbid = this.getNodeFromId(id.split("-")[1]).data.DBID
          let layer_to_delete = {
            id: layer_dbid,
          }
          deleteLayer(layer_to_delete).then(response => {
            if (response.ok) {
              super.removeNodeId(id)
            } else {
              errorNotification("Failed to delete layer.\n Server is not responding now.")
            }
          })
        }

        removeConnection() {
          const selectedConnection = this.connection_selected

          if (this.connectionIsNotRemovable()) return

          const connection_name = this.connection_selected.parentElement.className.animVal
          const parsed_connection_name = connection_name.split(" ")
          const layerInId = parsed_connection_name[1].split("-")[1]
          const layerOutId = parsed_connection_name[2].split("-")[1]

          const data1 = editor.getNodeFromId(layerOutId).data
          const data2 = editor.getNodeFromId(layerInId).data

          let connectionToDelete = {
            layer_from: data1.DBID,
            layer_to: data2.DBID,
          }

          console.log("Connection to delete: " + data1.DBID + " " + data2.DBID)

          deleteConnection(connectionToDelete).then(response => {
            if (response.ok) {
              this.connection_selected = selectedConnection
              super.removeConnection()

              let listOfConnections = data2.Connections

              for (let i = 0; i < listOfConnections.length; i++) {
                let parsedDBID = listOfConnections[i].split(";")[0]
                if (parsedDBID == data1.DBID) {
                  listOfConnections.splice(i, 1) // deletes connection from list
                  break
                }
              }

              editor.updateNodeDataFromId(layerInId, {
                DBID: data2.DBID,
                Connections: listOfConnections,
                Parameters: data2.Parameters,
              })
            } else {
              errorNotification("Failed to delete connection.\n Server is not responding now.")
            }
          })
        }

        addNode(name, inputs, outputs, posx, posy, classoverride, data, html) {
          const nameMap = {
            linear: "Linear",
            relu: "ReLU",
            data: "Data",
            output: "Output",
            loss: "MSELoss",
            target: "Target",
          }
          const parametersMap = {
            linear: "bias=0;inFeatures=1;outFeatures=2",
            relu: "",
            data: "width=2",
            output: "width=1",
            loss: "width=1",
            target: "width=1",
          }
          const layer = {
            type: nameMap[name],
            parameters: parametersMap[name],
          }
          addLayer(layer).then(async response => {
            if (response.ok) {
              const responseJson = await response.json()
              const attrs = {
                DBID: responseJson.layer_id,
                Connections: [],
                Parameters: layer.parameters,
              }
              super.addNode(name, inputs, outputs, posx, posy, classoverride, attrs, html)
            } else {
              errorNotification("Failed to add layer.\n Server is not responding now.")
            }
          })
        }
        import (data, notifi = true) {
          super.clear()
          this.drawflow = JSON.parse(JSON.stringify(data));
          this.load();
          if(notifi) {
            this.dispatch('import', 'import');
          }
        }

        clear() {
          Swal.fire({
            title: "Are you sure?",
            text: "You won't be able to revert this!",
            icon: "warning",
            showCancelButton: true,
            confirmButtonColor: "#3085d6",
            cancelButtonColor: "#d33",
            confirmButtonText: "Yes, clear the workspace!",
            allowOutsideClick: () => !Swal.isLoading(),
          }).then(result => {
            if (result.isConfirmed) {
              hideResult()
              onTrainShowPredict(false)
              clearModel().then(response => {
                if (response.ok) {
                  super.clear()
                  console.log("adding nodes")
                  addNodeToConstructor("data", 600, 430)
                  addNodeToConstructor("output", 1000, 430)
                  addNodeToConstructor("target", 550, 550)
                  addNodeToConstructor("loss", 860, 550)
                  Swal.fire("Deleted!", "Workspace has been cleared.", "success")
                } else {
                  errorNotification("Failed to clear.\n Server is not responding now.")
                }
              })
            }
          })
        }
        contextmenu(e) {
          if (this.node_selected) {
            try {
              showLayerInfo(this.node_selected.id)
            } catch (e) {
              console.log(e)
            }
          }
          this.dispatch("contextmenu", e)
          e.preventDefault()
          if (this.editor_mode === "fixed" || this.editor_mode === "view") {
            return false
          }
          if (this.precanvas.getElementsByClassName("drawflow-delete").length) {
            this.precanvas.getElementsByClassName("drawflow-delete")[0].remove()
          }
          if (this.node_selected || this.connection_selected) {
            let deletebox = document.createElement("div")
            deletebox.classList.add("drawflow-delete")
            deletebox.innerHTML = "x"
            if (this.node_selected && !this.node_selected.classList.contains("special")) {
              this.node_selected.appendChild(deletebox)
            }
            if (this.connection_selected && this.connection_selected.parentElement.classList.length > 1) {
              deletebox.style.top =
                e.clientY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) -
                this.precanvas.getBoundingClientRect().y *
                  (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) +
                "px"
              deletebox.style.left =
                e.clientX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) -
                this.precanvas.getBoundingClientRect().x *
                  (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) +
                "px"

              if (this.connectionIsNotRemovable()) return
              this.precanvas.appendChild(deletebox)
            }
          }
        }
        click(e) {
          deleteIdOnConnections()
          hideLayerInfo()
          super.click(e)
        }

        connectionIsNotRemovable() {
          const tmpListclassConnection = this.connection_selected.parentElement.classList
          const output_node_name = this.getNodeFromId(tmpListclassConnection[2].slice(14)).name
          const input_node_name = this.getNodeFromId(tmpListclassConnection[1].slice(13)).name
          if (output_node_name == "target" && input_node_name == "loss") return true
          return false
        }
      }


      id = document.getElementById("drawflow")
      let editor = new CustomDrawflow(id)


      let id = document.getElementById("drawflow")
      const editor = new CustomDrawflow(id)
      editor.start()
      let localStorageUsed = false
      editor.start()
      let editor_info = setCanvasFromLocalStorage(editor)
      if (editor_info != null) {
        console.log(editor_info)
        localStorageUsed = true
      }
      if (!localStorageUsed) {
        editor.addNode(
          "Data",
          0,
          1,
          300,
          320,
          "special",
          {},
          '<div class="title-box"><i class="fas fa-file-signature"></i> Data </div>',
        )
        editor.addNode(
          "Output",
          1,
          0,
          760,
          320,
          "special",
          {},
          '<div class="title-box"><i class="fas fa-file-signature"></i> Output </div>',
        )

        editor.addNode(
          "Target",
          0,
          1,
          450,
          450,
          "special",
          {},
          '<div class="title-box"><i class="fas fa-file-signature"></i> Target </div>',
        )

        editor.addNode(
          "Loss",
          1,
          0,
          760,
          450,
          "special",
          {},
          '<div class="title-box"><i class="fas fa-file-signature"></i> Loss </div>',
        )
      }

      saveCanvasToLocalStorage(editor)
      setup()

      async function setup() {
        try {
          addNodeToConstructor("data", 600, 430)
          addNodeToConstructor("output", 1000, 430)
          addNodeToConstructor("target", 550, 550)
          addNodeToConstructor("loss", 860, 550)
          console.log(`Setup completed successfully. \nUser ID: ${user_id} \nModel ID: ${model_id}`)
        } catch (err) {
          console.log(`Something went wrong during setup :( \nError: ${err}`)
        }
      }

      function errorNotification(errorText) {
        Swal.fire({
          position: "center",
          icon: "error",
          title: errorText,
          showConfirmButton: false,
          timer: 1500,
        })
      }


      // Events!
      editor.on("nodeCreated", function (id) {
        let last_created_node = editor.getNodeFromId(id)
        if (last_created_node.name == "loss") {
          let target_node = editor.getNodesFromName("target")[0]
          if (target_node) editor.addConnection(target_node, last_created_node.id, "output_1", "input_1")
        }
        if (last_created_node.name == "target") {
          let loss_node = editor.getNodesFromName("loss")[0]
          if (loss_node) editor.addConnection(last_created_node.id, loss_node, "output_1", "input_1")
        }
        console.log("Node created " + id)
        setModelView("irrelevant")
      })
      editor.on("nodeRemoved", function (id) {
        console.log("Node removed " + id)
        setModelView("irrelevant")
        saveCanvasToLocalStorage(editor)
      })
      editor.on("nodeSelected", function (id) {
        last_selected_node_id = id
        console.log("selected layer DBID: " + editor.getNodeFromId(id).data.DBID) // DBID = "database_id;drawflow_id"
        last_selected_layer_id = editor.getNodeFromId(id).data.DBID // database id of last selected layer
        console.log("layer parameters: " + editor.getNodeFromId(id).data.Parameters)
        console.log("Connections: " + editor.getNodeFromId(id).data.Connections)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("moduleCreated", function (name) {
        console.log("Module Created " + name)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("moduleChanged", function (name) {
        console.log("Module Changed " + name)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("connectionCreated", function (connection) {
        const data1 = editor.getNodeFromId(connection.output_id).data
        const data2 = editor.getNodeFromId(connection.input_id).data

        let layers_connection = {
          layer_from: data1.DBID,
          layer_to: data2.DBID,
        }

        addConnection(layers_connection).then(response => {
          if (response.ok) {
            editor.updateNodeDataFromId(connection.input_id, {
              DBID: data2.DBID,
              Connections: data2.Connections.concat(`${data1.DBID};${connection.output_id}`), // "db_id;drawflow_id"
              Parameters: data2.Parameters,
            })
          } else {
            errorNotification("Failed to add connection.\n Server is not responding now.")
            editor.removeSingleConnection(
              connection.output_id,
              connection.input_id,
              connection.output_class,
              connection.input_class,
            )
          }
        })
        saveCanvasToLocalStorage(editor)
      })

        setModelView("irrelevant")
      })
      editor.on("connectionRemoved", function (connection) {
        console.log("Connection removed")
        saveCanvasToLocalStorage(editor)

      })
      editor.on("nodeMoved", function (id) {
        console.log("Node moved " + id)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("zoom", function (zoom) {
        console.log("Zoom level " + zoom)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("addReroute", function (id) {
        console.log("Reroute added " + id)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("removeReroute", function (id) {
        console.log("Reroute removed " + id)
        saveCanvasToLocalStorage(editor)
      })

      const linear_bias_selector = document.getElementById("bias-parameter")
      linear_bias_selector.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_selected_node_id)
        console.log("last id: " + last_selected_layer_id)
        const new_value = document.getElementById("bias-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "bias") {
            if (new_value == "true") {
              console.log("bias true")
              parameters[i][1] = "1"
            } else {
              console.log("bias false")
              parameters[i][1] = "0"
            }
            joinUpdatedLayerParameters(parameters, last_selected_node_id)
            break
          }
        }
      })

      const linear_inFeatures_input = document.getElementById("linear-inFeatures-parameter")
      linear_inFeatures_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        console.log("last id: " + last_selected_layer_id)
        const new_value = document.getElementById("linear-inFeatures-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "inFeatures") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      linear_inFeatures_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const linear_outFeatures_input = document.getElementById("linear-outFeatures-parameter")
      linear_outFeatures_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        console.log("last id: " + last_selected_layer_id)
        const new_value = document.getElementById("linear-outFeatures-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "outFeatures") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      linear_outFeatures_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const special_width_input = document.getElementById("special-width-parameter")
      special_width_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        console.log("last id: " + last_selected_layer_id)
        const new_value = document.getElementById("special-width-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "width") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      special_width_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      /* DRAG EVENT */
      /* Mouse and Touch Actions */
      let elements = document.getElementsByClassName("drag-drawflow")
      for (let i = 0; i < elements.length; i++) {
        elements[i].addEventListener("touchend", drop, false)
        elements[i].addEventListener("touchmove", positionMobile, false)
        elements[i].addEventListener("touchstart", drag, false)
      }
      let mobile_item_selec = ""
      let mobile_last_move = null
      function positionMobile(ev) {
        mobile_last_move = ev
      }
      function allowDrop(ev) {
        ev.preventDefault()
      }
      function drag(ev, layer) {
        if (layer == "linear") {
          layer_drag_offset_X = ev.clientX - 50 // Linear layer offset X coord
          layer_drag_offset_Y = ev.clientY - 97 // Linear layer offset Y coord
        }
        if (layer == "relu") {
          layer_drag_offset_X = ev.clientX - 50 // Relu layer offset X coord
          layer_drag_offset_Y = ev.clientY - 163 // Relu layer offset Y coord
        }

        if (ev.type === "touchstart") {
          mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute("data-node")
        } else {
          ev.dataTransfer.setData("node", ev.target.getAttribute("data-node"))
        }
      }
      function drop(ev) {
        if (ev.type === "touchend") {
          const parentdrawflow = document
            .elementFromPoint(mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY)
            .closest("#drawflow")
          if (parentdrawflow != null) {
            addNodeToConstructor(
              mobile_item_selec,
              mobile_last_move.touches[0].clientX,
              mobile_last_move.touches[0].clientY,
            )
          }
          mobile_item_selec = ""
        } else {
          ev.preventDefault()
          const data = ev.dataTransfer.getData("node")
          addNodeToConstructor(data, ev.clientX, ev.clientY)
        }
      }

      function getParametersFromNode(id) {
        const layer_parameters = editor.getNodeFromId(id).data.Parameters
        const splited_parameters = layer_parameters.split(";")
        let parameters_array = []

        for (i in splited_parameters) {
          parameters_array.push(splited_parameters[i].split("="))
        }
        return parameters_array
      }

      function joinUpdatedLayerParameters(new_parameters, id) {
        let temp_array = []
        let new_parameters_string = null
        const dbid = editor.getNodeFromId(id).data.DBID
        const connections = editor.getNodeFromId(id).data.Connections

        let parameters_to_send = {
          id: dbid,
          parameters: null,
        }

        for (i in new_parameters) {
          temp_array.push(new_parameters[i].join("="))
        }
        new_parameters_string = temp_array.join(";")
        parameters_to_send["parameters"] = new_parameters_string
        console.log(parameters_to_send)

        updateLayerParameter(parameters_to_send).then(response => {
          if (response.ok) {
            editor.updateNodeDataFromId(id, {
              DBID: dbid,
              Connections: connections,
              Parameters: new_parameters_string,
            })
          } else {
            errorNotification("Failed to update parameters.\n Server is not responding now.")
            hideLayerInfo(id)
            showLayerInfo(id)
          }
        })
      }

      async function addNodeToConstructor(name, pos_x, pos_y) {
        if (editor.editor_mode === "fixed") return false

        pos_x =
          pos_x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) -
          editor.precanvas.getBoundingClientRect().x *
            (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom))
        pos_y =
          pos_y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) -
          editor.precanvas.getBoundingClientRect().y *
            (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom))

        pos_x -= layer_drag_offset_X
        pos_y -= layer_drag_offset_Y

        const empty_data = {}
        switch (name) {
          case "linear":
            const linear = `<div class="layer"><i class="fab moduleA"></i> Linear</div>`
            editor.addNode("linear", 1, 1, pos_x, pos_y, "linear", empty_data, linear)
            break
          case "relu":
            const relu = `<div class="layer"><i class="fab moduleA"></i> ReLU</div>`
            editor.addNode("relu", 1, 1, pos_x, pos_y, "relu", empty_data, relu)
            break
          case "data":
            const data = '<div class="title-box"><i class="fas fa-file-signature"></i> Data </div>'
            editor.addNode("data", 0, 1, pos_x, pos_y, "special", empty_data, data)
            break
          case "output":
            const output = '<div class="title-box"><i class="fas fa-file-signature"></i> Output </div>'
            editor.addNode("output", 1, 0, pos_x, pos_y, "special", empty_data, output)
            break
          case "target":
            const target = '<div class="title-box"><i class="fas fa-file-signature"></i> Target </div>'
            editor.addNode("target", 0, 1, pos_x, pos_y, "special", empty_data, target)
            break
          case "loss":
            const loss = '<div class="title-box"><i class="fas fa-file-signature"></i> Loss </div>'
            editor.addNode("loss", 1, 0, pos_x, pos_y, "special", empty_data, loss)
            break
          default:
            throw "Unreachable"
        }
      }

      let transform = ""
      function showpopup(e) {
        e.target.closest(".drawflow-node").style.zIndex = "9999"
        e.target.children[0].style.display = "block"

        transform = editor.precanvas.style.transform
        editor.precanvas.style.transform = ""
        editor.precanvas.style.left = editor.canvas_x + "px"
        editor.precanvas.style.top = editor.canvas_y + "px"

        editor.editor_mode = "fixed"
      }

      function closemodal(e) {
        e.target.closest(".drawflow-node").style.zIndex = "2"
        e.target.parentElement.parentElement.style.display = "none"
        editor.precanvas.style.transform = transform
        editor.precanvas.style.left = "0px"
        editor.precanvas.style.top = "0px"
        editor.editor_mode = "edit"
      }

      function changeMode(option) {
        //console.log(lock.id);
        if (option == "lock") {
          lock.style.display = "none"
          unlock.style.display = "block"
        } else {
          lock.style.display = "block"
          unlock.style.display = "none"
        }
      }
    </script>

    <!--Заглушки-->
    <script>
      function getLayerInfoFromDB(id) {
        //todo
        //взаимодействие с сервером, бд
      }
      function exportNN(NNdata) {
        //todo
      }
      function signOut() {
        localStorage.clear()
      }
      function openNNInConstructor(NNdata) {
        //todo
        //как-то построить схему нн до открытия конструктора
        //хранить html в бд?
        openConstructior()
      }
      function saveNN(name) {
        let save_success = saveNNhtmlToDB(name)
        let nn_id = 0
        if (save_success) addModelBlock(name, nn_id)
        return save_success
      }
      function saveNNhtmlToDB(name) {
        const nn_name = name
        const nn_html = JSON.stringify(editor.export(), null, 4)
        //some logic
        return true
      }
      function createNewNN() {
        editor.clear() //вместо этого перезапустить drawflow?
        openConstructior()
      }
    </script>

    <!--JSON requests handling-->
    <script>
      const csv_predict = document.getElementById("csv-predict-button")
      csv_predict.onclick = () => {
        csv_predict.value = null
      }

      csv_predict.addEventListener("input", predictRequest)

      function buildJsonFormData(form) {
        const jsonFormData = {}
        for (const pair of new FormData(form)) {
          jsonFormData[pair[0]] = Number(pair[1])
        }
        return jsonFormData
      }

      // function buildTrainData(form) {
      //   let input = []
      //   let output = []
      //   let loss = []
      //   let target = []
      //   const jsonFormData = {}

      //   for (const pair of new FormData(form)) {
      //     if (pair[0] == "res") {
      //       output.push(Number(pair[1]))
      //     } else {
      //       input.push(Number(pair[1]))
      //     }
      //   }

      //   jsonFormData["0"] = input // 0 - id Data layer
      //   jsonFormData["1"] = output // 1 - id Output layer TODO: id of target block here
      //   jsonFormData["2"] = loss
      //   jsonFormData["3"] = target

      //   console.log(jsonFormData)
      //   return {dataset: jsonFormData}
      // }
    </script>

    <!-- JS scripts -->
    <script>
      const dataLayerId = 1
      const outputLayerId = 2
      const targetLayerId = 3
      const lossLayerId = 4
      //import {user_id, py_server_address} from "../scripts/auth.js"
      const user_id = localStorage.getItem("user_id")
      const model_id = localStorage.getItem("model_id")
      const py_server_address = localStorage.getItem("py_server_address")

      console.log(`current user id: ${user_id}`)

      let last_selected_layer_id // layer's db id
      let last_changed_parameters_layer_id
      let train_status = false
      var last_selected_node_id // not db id

      // Функция, позволяющая вызывать другю функцию через ms времени
      const delay = async ms => await new Promise(resolve => setTimeout(resolve, ms))
      if (!localStorageUsed) {
        setup()
      }

      async function setup() {
        try {
          let ObjData = {
            type: "Data",
            parameters: "inputs=0;outputs=1;width=2",
          }

          let ObjOutput = {
            type: "Output",
            parameters: "inputs=1;outputs=0;width=1",
          }

          let ObjTarget = {
            type: "Target",
            parameters: "inputs=0;outputs=1;width=1",
          }

          let ObjLoss = {
            type: "MSELoss",
            parameters: "inputs=2;outputs=0;width=1",
          }

          addLayer(ObjData)
            .then(id =>
              editor.updateNodeDataFromId(dataLayerId, {
                DBID: id,
                Connections: [],
                Parameters: ObjData.parameters,
              }),
            )
            .then(() =>
              addLayer(ObjOutput).then(id =>
                editor.updateNodeDataFromId(outputLayerId, {
                  DBID: id,
                  Connections: [],
                  Parameters: ObjOutput.parameters,
                }),
              ),
            )
            .then(() =>
              addLayer(ObjTarget).then(id =>
                editor.updateNodeDataFromId(targetLayerId, {
                  DBID: id,
                  Connections: [],
                  Parameters: ObjTarget.parameters,
                }),
              ),
            )
            .then(() =>
              addLayer(ObjLoss).then(id =>
                editor.updateNodeDataFromId(lossLayerId, {
                  DBID: id,
                  Connections: [],
                  Parameters: ObjLoss.parameters,
                }),
              ),
            )
            .then(() => console.log(`Setup completed successfully. \nUser ID: ${user_id} \nModel ID: ${model_id}`))
        } catch (err) {
          console.log(`Something went wrong during setup :( \nError: ${err}`)
        }
      }

      let layer_drag_offset_X = 0
    </script>

    <!--Общее взаимодействие html и js-->
    <script>
      function showMode(event) {
        let all = document.querySelectorAll(".menu ul li")
        let modes = document.querySelectorAll("div.home, div.constructor, div.terminal, div.metrics")
        for (let i = 0; i < all.length; i++) {
          all[i].classList.remove("selected")
          modes[i].style.display = "none"
        }
        event.target.classList.add("selected")
        document.getElementById(event.target.id.split("-")[1]).style.display = "flex"
      }
      function showProfile() {
        let prf = document.getElementById("profile")
        if (prf.style.display == "block") prf.style.display = "none"
        else prf.style.display = "block"
      }
    </script>

    <!--Домашний экран-->
    <script>
      function addModelBlock(name, nn_id) {
        if (name == "") name = "New Neural Network"
        let container = document.getElementById("nn-container")
        let str = `'            <div class="nn-block">
                <data id="id" value="${nn_id}"></data>
                <span class="text-wrapper"> ${name} </span>
                <label class="button-wrapper">
                    Open
                    <input type="button" onclick="openNNInConstructor(this.parentElement.parentElement.children[0])"> <!--передает id nn-->
                </label>
                <label class="button-wrapper">
                    Export
                    <input type="button" onclick="exportNN()">
                </label>
                <label class="button-wrapper">
                    Delete
                    <input type="button" class="profile-check" onclick="deleteModelBlock(this.parentElement.parentElement)">
                </label>
            </div>'`
        container.innerHTML += str.substring(1, str.length - 1)
      }
      function deleteModelBlock(elem) {
        Swal.fire({
          title: "Delete the network?",
          text: "You won't be able to revert this!",
          icon: "warning",
          showCancelButton: true,
          confirmButtonColor: "#3085d6",
          cancelButtonColor: "#d33",
          confirmButtonText: "Yes, delete it!",
          allowOutsideClick: () => !Swal.isLoading(),
        }).then(result => {
          if (result.isConfirmed) {
            //delete nn from db
            //verify deletion
            elem.remove()
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Deleted!",
              text: "Neural network has been deleted",
              showConfirmButton: false,
              timer: 1500,
            })
          }
        })
      }
      function uploadModel() {
        addModelBlock()
      }
      function changeNNShowMode() {}
      function openConstructior() {
        const all = document.querySelectorAll(".menu ul li")
        const modes = document.querySelectorAll("div.home, div.constructor, div.terminal, div.metrics")
        for (let i = 0; i < all.length; i++) {
          all[i].classList.remove("selected")
          modes[i].style.display = "none"
        }
        const constructor = document.getElementById("constructor")
        constructor.classList.add("selected")
        constructor.style.display = "flex"
      }
    </script>

    <!--Конструктор-->
    <script>
      // Notifications
      const buildSuccessful = () => {
        Swal.fire({
          position: "top-end",
          icon: "success",
          title: "Neural network has been built",
          showConfirmButton: false,
          timer: 1500,
        })
      }
      const buildUnsuccessful = () => {
        Swal.fire({
          position: "top-end",
          icon: "error",
          title: "Failed to build neural network",
          showConfirmButton: false,
          timer: 1500,
        })
      }
      const showBuildNotification = build_status => {
        build_status ? buildSuccessful() : buildUnsuccessful()
      }
      async function csvUploaded() {
        if (csv_upload.files.length == 0) return
        const file = csv_upload.files[0]
        const text = await file.text()
        // do whatever with the `text`
        setModelView("irrelevant")
        console.log(`Got goods: ${text}`)
        train_data = text
        // allow user to press a train button from now on
        button_wrapper = document.getElementById("train-button")
        button_wrapper.getElementsByTy
        train_button = button_wrapper.children[0]
        button_wrapper.removeAttribute("disabled")
        train_button.removeAttribute("disabled")
      }
      const csv_upload = document.getElementById("csv-upload-button")
      csv_upload.addEventListener("change", csvUploaded)

      function onTrainShowPredict(training_successful) {
        const predict_button = document.getElementById("csv-predict-button")
        hideResult() // hide result when new training results arrive
        if (training_successful) {
          predict_button.removeAttribute("disabled")
          predict_button.parentElement.removeAttribute("disabled")
        } else {
          predict_button.setAttribute("disabled", "")
          predict_button.parentElement.setAttribute("disabled", "")
        }
      }
      function onPredictShowResult(res) {
        document.getElementById("res-value-out").innerHTML = res.replace(/[^\d.-]/g, "") // extract number from it for now
        document.getElementById("predict-result-wrapper").style.textAlign = "center"
        document.getElementById("predict-result-wrapper").style.display = "block"
      }

      // Array of connections with written id (input selection)
      let pathsWithWrittenID = []
      function writeIdOnConnections(id) {
        const connections = editor.getNodeFromId(id).data.Connections

        for (let connection of connections) {
          const from_layer_drawflow_id = connection.split(";")[1]
          const htmlConnection = document.querySelector(
            `.connection.node_in_node-${id}.node_out_node-${from_layer_drawflow_id}.output_1.input_1`,
          )
          const tmp = addLabelText(htmlConnection, connection.split(";")[0]) // Writes id on connection
          pathsWithWrittenID.push(tmp)
        }
      }

      // Remove id written on connection
      function deleteIdOnConnections() {
        for (let path of pathsWithWrittenID) {
          path.setAttribute("display", "none")
        }
        pathsWithWrittenID = []
      }

      function getSortableInputList(layerClass) {
        switch (layerClass) {
          case "linear":
            return document.querySelector("#linear-inputs-sortable-list")
          case "relu":
            return document.querySelector("#relu-inputs-sortable-list")
          case "special":
            return document.querySelector("#special-inputs-sortable-list")
        }
      }

      function hideResult() {
        document.getElementById("predict-result-wrapper").style.display = "none"
      }
      function showLayerInfo(id) {
        // id format "node-<id>"
        let correct_id = id
        if (id.includes("node")) {
          correct_id = id.split("-")[1]
        }
        const node = editor.getNodeFromId(correct_id)
        const connections = editor.getNodeFromId(correct_id).data.Connections
        const layer_dbid = editor.getNodeFromId(correct_id).data.DBID

        // Input selection
        writeIdOnConnections(correct_id)
        let sortable_list = getSortableInputList(node.class)
        let child = sortable_list.lastElementChild

        while (child) {
          sortable_list.removeChild(child)
          child = sortable_list.lastElementChild
        }
        let input_list = document.getElementsByClassName("layer-input-list")
        for (let elem of input_list) elem.style.display = "none"
        let counter = 0
        for (let connection of connections) {
          for (let elem of input_list) elem.style.display = "block"
          let new_element = document.createElement("LI")
          counter += 1
          const text_for_new_element = document.createTextNode(`${counter} input ID: ` + connection.split(";")[0])
          new_element.appendChild(text_for_new_element)
          sortable_list.appendChild(new_element)
        }

        let new_input_order = []
        new Sortable(sortable_list, {
          animation: 150,
          ghostClass: "sortable-ghost",
          onEnd: function (event) {
            new_input_order = []
            for (let i in sortable_list.childNodes) {
              try {
                if (sortable_list.childNodes[i].textContent.includes("input")) {
                  new_input_order.push(Number(sortable_list.childNodes[i].textContent.split(" ")[3]))
                }
              } catch (e) {
                continue
              }
            }

            let newConnections = []
            for (let i = 0; i < new_input_order.length; i++) {
              for (let connection of connections) {
                if (new_input_order[i] == connection.split(";")[0]) {
                  newConnections[i] = connection
                }
              }
            }
            let new_inputs_object = {
              new_parents: new_input_order,
              layer_id: layer_dbid,
            }
            updateParentOrder(new_inputs_object).then(response => {
              if (response.ok) {
                editor.updateNodeDataFromId(correct_id, {
                  DBID: layer_dbid,
                  Connections: newConnections,
                  Parameters: editor.getNodeFromId(correct_id).data.Parameters,
                })
              } else {
                errorNotification("Failed to update input order.\n Server is not responding now.")
              }
            })
          },
        })

        document.getElementById("layer-data").style.display = "block"
        document.getElementById("layer-id").innerHTML = "ID: " + layer_dbid.toString()

        const layer_parameters = getParametersFromNode(correct_id)

        if (node.class == "linear") {
          document.querySelector("#linear-layer-parameters").style.display = "block"

          for (i in layer_parameters) {
            if (layer_parameters[i][0] == "bias") {
              document.querySelector("#bias-parameter").value = layer_parameters[i][1] == "1"
            }
            if (layer_parameters[i][0] == "inFeatures") {
              document.querySelector("#linear-inFeatures-parameter").value = layer_parameters[i][1]
            }
            if (layer_parameters[i][0] == "outFeatures") {
              document.querySelector("#linear-outFeatures-parameter").value = layer_parameters[i][1]
            }
          }
        } else if (node.class == "special") {
          document.querySelector("#special-layer-parameters").style.display = "block"

          for (i in layer_parameters) {
            if (layer_parameters[i][0] == "width") {
              document.querySelector("#special-width-parameter").value = layer_parameters[i][1]
            }
          }
        } else if (node.class == "relu") {
          document.querySelector("#relu-layer-parameters").style.display = "block"
        }
      }
      function hideLayerInfo() {
        document.getElementById("layer-data").style.display = "none"

        document.querySelector("#linear-layer-parameters").style.display = "none"
        document.querySelector("#special-layer-parameters").style.display = "none"
        document.querySelector("#relu-layer-parameters").style.display = "none"

        deleteIdOnConnections()
      }

      function addLabelText(path, labelText) {
        try {
          const newid = [path.classList].join().replace(/\s/g, "")
          path.childNodes[0].id = newid
          let textElem = document.createElementNS(path.namespaceURI, "text")
          let textElemPath = document.createElementNS(path.namespaceURI, "textPath")
          textElemPath.setAttribute("href", `#${newid}`)
          textElemPath.setAttribute("text-anchor", "middle")
          textElemPath.setAttribute("startOffset", "50%")
          textElemPath.setAttribute("style", "font-size:30px")
          textElemPath.textContent = labelText
          textElemPath.classList.add("label-text")
          textElem.appendChild(textElemPath)
          path.appendChild(textElem)
          return textElemPath
        } catch (e) {}
      }

      function save() {
        Swal.fire({
          title: "Enter the name of your neural network",
          input: "text",
          inputAttributes: {
            autocapitalize: "off",
          },
          showCancelButton: true,
          confirmButtonText: "Save",
          showLoaderOnConfirm: true,
          preConfirm: name => {
            return saveNN(name) //еще нужно проверить корректность name
          },
          allowOutsideClick: () => !Swal.isLoading(),
        }).then(result => {
          if (result.isConfirmed) {
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Neural network has been saved",
              showConfirmButton: false,
              timer: 1500,
            })
          }
        })
      }

      let modelIsUpToDate = "irrelevant"
      function setModelView(state) {
        modelIsUpToDate = state
        let nodes = document.getElementsByClassName("drawflow-node")
        let connections = document.getElementsByClassName("main-path")

        if (state == "success") {
          for (let node of nodes) {
            if (!node.classList.contains("predict-success")) node.classList.add("predict-success")
            if (node.classList.contains("predict-error")) node.classList.remove("predict-error")
          }
          for (let connection of connections) {
            if (!connection.classList.contains("connection-predict-success"))
              connection.classList.add("connection-predict-success")
            if (connection.classList.contains("connection-predict-error"))
              connection.classList.remove("connection-predict-error")
          }
        } else if (state == "error") {
          for (let node of nodes) {
            if (node.classList.contains("predict-up-to-success")) node.classList.remove("predict-success")
            if (!node.classList.contains("predict-error")) node.classList.add("predict-error")
          }
          for (let connection of connections) {
            if (connection.classList.contains("connection-predict-success"))
              connection.classList.remove("connection-predict-success")
            if (!connection.classList.contains("connection-predict-error"))
              connection.classList.add("connection-predict-error")
          }
        } else {
          for (let node of nodes) {
            if (node.classList.contains("predict-error")) node.classList.remove("predict-error")
            if (node.classList.contains("predict-success")) node.classList.remove("predict-success")
          }
          for (let connection of connections) {
            if (connection.classList.contains("connection-predict-error"))
              connection.classList.remove("connection-predict-error")
            if (connection.classList.contains("connection-predict-success"))
              connection.classList.remove("connection-predict-success")
          }
        }
      }
    </script>

    <!--Терминал-->
    <script></script>

    <!--Метрика-->
    <script></script>
  </body>
</html>
