<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>MLCraft</title>
    <meta name="description" content="none yet" />
    <script src="../scripts/storage.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"
      integrity="sha256-KzZiKy0DWYsnwMF+X1DvQngQ2/FxF7MF3Ff72XcpuPs="
      crossorigin="anonymous"
    ></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css" />
    <link rel="stylesheet" type="text/css" href="../styles/style.css" />
    <link rel="stylesheet" type="text/css" href="../styles/palette.css" />
    <link rel="stylesheet" type="text/css" href="../styles/day_night_mode.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
      integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ="
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@9"></script>
    <script src="https://unpkg.com/micromodal/dist/micromodal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.13.0/Sortable.min.js"></script>
    <script src="../scripts/day_night_mode.js"></script>
    <script src="../scripts/requests.js"></script>
  </head>
  <body>
    <!-- HTML parts -->
    <header>
      <label class="button-wrapper">
        <input type="button" class="profile-check" onclick="showProfile()" />
        <i
          class="material-icons"
          style="font-size: 65px; position: relative; left: -7px; bottom: 2px"
          onmousedown="return false"
          >person</i
        >
      </label>
      <h2 onmousedown="return false">MLCraft</h2>
      <div class="github-link">
        <a href="https://github.com/SPbuMinecraft/GraphicalEditorForNN" target="_blank"
          ><i class="fab fa-github fa-3x" style="color: var(--background3)"></i
        ></a>
      </div>
      <div class="menu" onmousedown="return false">
        <ul>
          <li id="select-home" onclick="showMode(event);">Home</li>
          <li id="select-constructor" onclick="showMode(event);" class="selected">Constructor</li>
          <li id="select-metrics" onclick="showMode(event);">Metrics</li>
        </ul>
      </div>
    </header>

    <div class="profile" id="profile">
      <a style="text-decoration: none" href="../index.html" onclick="signOut()">
        <input class="button-wrapper" type="button" id="sing-out-button" value="Sign out" />
      </a>
      <label class="day-night-mode-label">
        <input
          type="checkbox"
          id="day-night-checkbox-id"
          class="day-night-checkbox"
          value="day"
          onclick="changeTheme()"
        />
        <span class="control"></span>
      </label>
    </div>

    <div class="home" id="home">
      <div class="background">
        <div class="nn-container-class" id="nn-container"></div>
        <div class="nn-block" id="new-nn">
          <label class="button-wrapper">
            Create
            <input type="button" onclick="createNewNN()" /> </label
          ><br />
          <label class="button-wrapper">
            Upload
            <input type="file" id="onnx-upload-button" accept=".onnx" oninput="uploadModel()" />
          </label>
        </div>
      </div>
    </div>
    <!--Меню выбора блоков  -->
    <div class="constructor" id="constructor">
      <div class="col">
        <br />
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `linear`)" data-node="linear">
          <span> Linear</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `relu`)" data-node="relu">
          <span> ReLU</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `pooling`)" data-node="pooling">
          <span> Pooling</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `layernorm`)" data-node="layernorm">
          <span> LayerNorm</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event, `conv2d`)" data-node="conv2d">
          <span> Conv2D</span>
        </div>
        <br />

        <label class="button-wrapper">
          Upload
          <input type="file" id="dataset-upload-button" accept=".csv,.zip" />
        </label>

        <label class="button-wrapper" id="train-button" disabled>
          Train
          <input type="button" onclick="trainRequest()" disabled />
        </label>

        <label class="button-wrapper" disabled>
          Predict
          <input type="file" accept=".png" id="predict-button" disabled />
        </label>
        <div class="predict-result-wrapper" id="predict-result-wrapper">
          <output class="form-control-res" id="res-value-out" name="res-value" for="x-value y-value"></output>
        </div>
      </div>

      <div class="col-right">
        <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)">
          <div class="btn-save" onclick="save()">Save</div>
          <div class="btn-clear" onclick="clearCanvas()">Clear</div>
          <div class="btn-lock">
            <i id="lock" class="fas fa-lock" onclick="editor.editor_mode='fixed'; changeMode('lock');"></i>
            <i
              id="unlock"
              class="fas fa-lock-open"
              onclick="editor.editor_mode='edit'; changeMode('unlock');"
              style="display: none"
            ></i>
          </div>
          <div class="bar-zoom">
            <i class="fas fa-search-minus" onclick="editor.zoom_out()"></i>
            <i class="fas fa-search" onclick="editor.zoom_reset()"></i>
            <i class="fas fa-search-plus" onclick="editor.zoom_in()"></i>
          </div>
        </div>
      </div>

      <div class="layer-data" id="layer-data">
        <h2>Parameters</h2>
        <label id="layer-id"></label>
        <h3></h3>
        <div class="linear-layer-parameters layer-parameters" id="linear-layer-parameters" style="display: none">
          <label for="bias-parameter">Bias</label>
          <select id="bias-parameter">
            <option value="true">true</option>
            <option value="false">false</option>
          </select>
          <h3></h3>
          <label for="linear-inFeatures-parameter">inFeatures</label>
          <input id="linear-inFeatures-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <label for="linear-outFeatures-parameter"> outFeatures </label>
          <input id="linear-outFeatures-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="linear-input-selection">
            <label class="layer-input-list" style="display: none"> Input ID order: </label>
            <ul id="linear-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="relu-layer-parameters layer-parameters" id="relu-layer-parameters" style="display: none">
          <label for="relu-width-parameter">Width</label>
          <input id="relu-width-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="relu-input-selection">
            <label class="layer-input-list" style="display: none">Input ID order: </label>
            <ul id="relu-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="pooling-layer-parameters layer-parameters" id="pooling-layer-parameters" style="display: none">
          <div id="pooling-input-selection">
            <label class="layer-input-list" style="display: none">Input ID order: </label>
            <ul id="pooling-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="layernorm-layer-parameters layer-parameters" id="layernorm-layer-parameters" style="display: none">
          <label for="layernorm-axis-parameter">Axis</label>
          <input id="layernorm-axis-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="layernorm-input-selection">
            <label class="layer-input-list" style="display: none">Input ID order: </label>
            <ul id="layernorm-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="conv2d-layer-parameters layer-parameters" id="conv2d-layer-parameters" style="display: none">
          <label for="conv2d-KernelSize-parameter">kernelSize</label>
          <input id="conv2d-KernelSize-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <label for="conv2d-inChannels-parameter">inChannels</label>
          <input id="conv2d-inChannels-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <label for="conv2d-outChannels-parameter">outChannels</label>
          <input id="conv2d-outChannels-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="conv2d-input-selection">
            <label class="layer-input-list" style="display: none">Input ID order: </label>
            <ul id="conv2d-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="special-layer-parameters layer-parameters" id="special-layer-parameters" style="display: none">
          <label for="special-width-parameter">Width</label>
          <input id="special-width-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <div id="special-input-selection">
            <label class="layer-input-list" style="display: none"> Input ID order: </label>
            <ul id="special-inputs-sortable-list"></ul>
          </div>
        </div>

        <div class="loss-layer-parameters layer-parameters" id="loss-layer-parameters" style="display: none">
          <label for="loss-width-parameter">Width</label>
          <input id="loss-width-parameter" type="number" value="1" size="4" />
          <h3></h3>
          <label for="loss-type-parameter">Loss type</label>
          <select id="loss-type-parameter">
            <option value="MSELoss">MSELoss</option>
            <option value="CrossEntropyLoss">CrossEntropyLoss</option>
          </select>
          <div id="loss-input-selection">
            <ul id="loss-inputs-sortable-list"></ul>
          </div>
        </div>
      </div>
    </div>

    <div class="metrics" id="metrics">Coming soon!</div>

    <!--Работа с Drawflow-->
    <script>
      function saveCanvasToLocalStorage(editorObj) {
        // Переводим объект в строку JSON

        let jsonString = JSON.stringify(editorObj.export())
        // Сохраняем строку в LocalStorage с определенным ключом
        localStorage.setItem("canvas", jsonString)
      }

      function setCanvasFromLocalStorage(editorObj) {
        // Получаем строку из LocalStorage по ключу
        const jsonString = localStorage.getItem("canvas")
        // Если строка не пуста, преобразуем её в объект
        if (jsonString) {
          let json = JSON.parse(jsonString)
          editorObj.import(json, (notifi = false))
          return json
        } else {
          // Если строка пуста (ключ отсутствует или значение null), возвращаем null или другое значение по умолчанию
          return null
        }
      }

      function clearAlert(completion) {
        Swal.fire({
          title: "Clear the workspace?",
          text: "You won't be able to revert this!",
          icon: "warning",
          showCancelButton: true,
          confirmButtonColor: "#3085d6",
          cancelButtonColor: "#d33",
          confirmButtonText: "Yes, clear it!",
          allowOutsideClick: () => !Swal.isLoading(),
        }).then(completion)
      }

      function clearCanvas() {
        clearAlert(result => {
          if (result.isConfirmed) {
            editor.clear()
            hideResult()
            onTrainShowPredict(false)
            //add success verification
            clearModel().then(() => {
              console.log("adding one node")
              // TODO: WHY IS THIS, FIX PARALLEL DB
              addNodeToConstructor("data", 600, 430).then(() => {
                console.log("adding the other")
                addNodeToConstructor("output", 1000, 430).then(() => {
                  addNodeToConstructor("target", 550, 550).then(() => {
                    addNodeToConstructor("loss", 860, 550)
                  })
                })
              })
            })
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Cleared!",
              text: "Workspace has been cleared",
              showConfirmButton: false,
              timer: 1500,
            })
          }
        })
      }

      class CustomDrawflow extends Drawflow {
        constructor(id) {
          super(id)
        }
        removeNodeId(id) {
          let nodeClassFromId = this.getNodeFromId(id.slice(5)).class
          if (nodeClassFromId === "special") {
            return
          }
          const layer_dbid = this.getNodeFromId(id.split("-")[1]).data.DBID
          let layer_to_delete = {
            id: layer_dbid,
          }
          deleteLayer(layer_to_delete).then(response => {
            if (response.ok) {
              super.removeNodeId(id)
              updateConnectionsInLayers(id.split("-")[1])
            } else {
              errorNotification("Failed to delete layer.\n Server is not responding now.")
            }
          })
        }

        removeConnection() {
          const selectedConnection = this.connection_selected

          if (this.connectionIsNotRemovable()) return

          const connection_name = this.connection_selected.parentElement.className.animVal
          const parsed_connection_name = connection_name.split(" ")
          const layerInId = parsed_connection_name[1].split("-")[1]
          const layerOutId = parsed_connection_name[2].split("-")[1]

          const data1 = editor.getNodeFromId(layerOutId).data
          const data2 = editor.getNodeFromId(layerInId).data

          let connectionToDelete = {
            layer_from: data1.DBID,
            layer_to: data2.DBID,
          }

          console.log("Connection to delete: " + data1.DBID + " " + data2.DBID)

          deleteConnection(connectionToDelete).then(response => {
            if (response.ok) {
              setModelView("irrelevant")
              this.connection_selected = selectedConnection
              super.removeConnection()

              let listOfConnections = data2.Connections

              for (let i = 0; i < listOfConnections.length; i++) {
                let parsedDBID = listOfConnections[i].split(";")[0]
                if (parsedDBID == data1.DBID) {
                  listOfConnections.splice(i, 1) // deletes connection from list
                  break
                }
              }

              editor.updateNodeDataFromId(layerInId, {
                DBID: data2.DBID,
                Connections: listOfConnections,
                Parameters: data2.Parameters,
              })
            } else {
              errorNotification("Failed to delete connection.\n Server is not responding now.")
            }
          })
        }

        addNode(name, inputs, outputs, posx, posy, classoverride, data, html) {
          const nameMap = {
            linear: "Linear",
            relu: "ReLU",
            pooling: "Pooling",
            layernorm: "LayerNorm",
            conv2d: "Conv2D",
            data: "Data",
            output: "Output",
            loss: "MSELoss",
            target: "Target",
          }
          const parametersMap = {
            linear: "bias=0;inFeatures=2;outFeatures=1",
            relu: "",
            pooling: "",
            layernorm: "axis=1",
            conv2d: "kernelSize=1;inChannels=1;outChannels=1",
            data: "shape=[3,512,512]",
            output: "",
            loss: "",
            target: "shape=[1]",
          }
          const layer = {
            type: nameMap[name],
            parameters: parametersMap[name],
          }
          addLayer(layer).then(async response => {
            if (response.ok) {
              const responseJson = await response.json()
              const attrs = {
                DBID: responseJson.layer_id,
                Connections: [],
                Parameters: layer.parameters,
              }
              super.addNode(name, inputs, outputs, posx, posy, classoverride, attrs, html)
            } else {
              errorNotification("Failed to add layer.\n Server is not responding now.")
            }
          })
        }
        import(data, notifi = true) {
          super.clear()
          this.drawflow = JSON.parse(JSON.stringify(data))
          this.load()
          if (notifi) {
            this.dispatch("import", "import")
          }
        }
        contextmenu(e) {
          if (this.node_selected) {
            try {
              showLayerInfo(this.node_selected.id)
            } catch (e) {
              console.log(e)
            }
          }
          this.dispatch("contextmenu", e)
          e.preventDefault()
          if (this.editor_mode === "fixed" || this.editor_mode === "view") {
            return false
          }
          if (this.precanvas.getElementsByClassName("drawflow-delete").length) {
            this.precanvas.getElementsByClassName("drawflow-delete")[0].remove()
          }
          if (this.node_selected || this.connection_selected) {
            let deletebox = document.createElement("div")
            deletebox.classList.add("drawflow-delete")
            deletebox.innerHTML = "x"
            if (this.node_selected && !this.node_selected.classList.contains("special")) {
              this.node_selected.appendChild(deletebox)
            }
            if (this.connection_selected && this.connection_selected.parentElement.classList.length > 1) {
              deletebox.style.top =
                e.clientY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) -
                this.precanvas.getBoundingClientRect().y *
                  (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) +
                "px"
              deletebox.style.left =
                e.clientX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) -
                this.precanvas.getBoundingClientRect().x *
                  (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) +
                "px"

              if (this.connectionIsNotRemovable()) return
              this.precanvas.appendChild(deletebox)
            }
          }
        }
        click(e) {
          hideLayerInfo()
          super.click(e)
        }

        connectionIsNotRemovable() {
          const tmpListclassConnection = this.connection_selected.parentElement.classList
          const output_node_name = this.getNodeFromId(tmpListclassConnection[2].slice(14)).name
          const input_node_name = this.getNodeFromId(tmpListclassConnection[1].slice(13)).name
          if (output_node_name == "target" && input_node_name == "loss") return true
          return false
        }
      }

      let id = document.getElementById("drawflow")
      const editor = new CustomDrawflow(id)
      editor.start()
      let localStorageUsed = false
      let editor_info = setCanvasFromLocalStorage(editor)
      if (editor_info != null) {
        console.log(editor_info)
        localStorageUsed = true
      }
      if (!localStorageUsed) {
        setup()
        saveCanvasToLocalStorage(editor)
      }

      async function setup() {
        try {
          addNodeToConstructor("data", 600, 430)
          addNodeToConstructor("output", 1000, 430)
          addNodeToConstructor("target", 550, 550)
          addNodeToConstructor("loss", 860, 550)
          console.log(`Setup completed successfully. \nUser ID: ${user_id} \nModel ID: ${model_id}`)
        } catch (err) {
          console.log(`Something went wrong during setup :( \nError: ${err}`)
        }
      }

      function errorNotification(errorText) {
        Swal.fire({
          position: "center",
          icon: "error",
          title: errorText,
          showConfirmButton: false,
          timer: 1500,
        })
      }

      // Events!
      editor.on("nodeCreated", function (id) {
        let last_created_node = editor.getNodeFromId(id)
        if (last_created_node.name == "loss") {
          let target_node = editor.getNodesFromName("target")[0]
          if (target_node) editor.addConnection(target_node, last_created_node.id, "output_1", "input_1")
        }
        if (last_created_node.name == "target") {
          let loss_node = editor.getNodesFromName("loss")[0]
          if (loss_node) editor.addConnection(last_created_node.id, loss_node, "output_1", "input_1")
        }
        console.log("Node created " + id)
        setModelView("irrelevant")
      })
      editor.on("nodeRemoved", function (id) {
        console.log("Node removed " + id)
        setModelView("irrelevant")
        saveCanvasToLocalStorage(editor)
      })
      editor.on("nodeSelected", function (id) {
        last_selected_node_id = id
        console.log("selected layer DBID: " + editor.getNodeFromId(id).data.DBID) // DBID = "database_id;drawflow_id"
        last_selected_layer_id = editor.getNodeFromId(id).data.DBID // database id of last selected layer
        console.log("layer parameters: " + editor.getNodeFromId(id).data.Parameters)
        console.log("Connections: " + editor.getNodeFromId(id).data.Connections)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("moduleCreated", function (name) {
        console.log("Module Created " + name)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("moduleChanged", function (name) {
        console.log("Module Changed " + name)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("connectionCreated", function (connection) {
        const data1 = editor.getNodeFromId(connection.output_id).data
        const data2 = editor.getNodeFromId(connection.input_id).data

        let layers_connection = {
          layer_from: data1.DBID,
          layer_to: data2.DBID,
        }

        addConnection(layers_connection).then(response => {
          if (response.ok) {
            editor.updateNodeDataFromId(connection.input_id, {
              DBID: data2.DBID,
              Connections: [].concat(`${data1.DBID};${connection.output_id}`, data2.Connections), // "db_id;drawflow_id"
              Parameters: data2.Parameters,
            })
          } else {
            errorNotification("Failed to add connection.\n Server is not responding now.")
            editor.removeSingleConnection(
              connection.output_id,
              connection.input_id,
              connection.output_class,
              connection.input_class,
            )
          }
        })
        saveCanvasToLocalStorage(editor)
        setModelView("irrelevant")
      })
      editor.on("connectionRemoved", function (connection) {
        console.log("Connection removed")
        saveCanvasToLocalStorage(editor)
      })
      editor.on("nodeMoved", function (id) {
        console.log("Node moved " + id)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("zoom", function (zoom) {
        console.log("Zoom level " + zoom)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("addReroute", function (id) {
        console.log("Reroute added " + id)
        saveCanvasToLocalStorage(editor)
      })
      editor.on("removeReroute", function (id) {
        console.log("Reroute removed " + id)
        saveCanvasToLocalStorage(editor)
      })

      //linear
      const linear_bias_selector = document.getElementById("bias-parameter")
      linear_bias_selector.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_selected_node_id)
        const new_value = document.getElementById("bias-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "bias") {
            if (new_value == "true") {
              console.log("bias true")
              parameters[i][1] = "1"
            } else {
              console.log("bias false")
              parameters[i][1] = "0"
            }
            joinUpdatedLayerParameters(parameters, last_selected_node_id)
            break
          }
        }
      })

      const linear_inFeatures_input = document.getElementById("linear-inFeatures-parameter")
      linear_inFeatures_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("linear-inFeatures-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "inFeatures") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      linear_inFeatures_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const linear_outFeatures_input = document.getElementById("linear-outFeatures-parameter")
      linear_outFeatures_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("linear-outFeatures-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "outFeatures") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      linear_outFeatures_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      //layernorm
      const layernorm_axis_input = document.getElementById("layernorm-axis-parameter")
      layernorm_axis_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("layernorm-axis-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "axis") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      layernorm_axis_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      //conv2d
      const conv2d_KernelSize_input = document.getElementById("conv2d-KernelSize-parameter")
      conv2d_KernelSize_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("conv2d-KernelSize-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "kernelSize") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      conv2d_KernelSize_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const conv2d_inChannels_input = document.getElementById("conv2d-inChannels-parameter")
      conv2d_inChannels_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("conv2d-inChannels-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "inChannels") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      conv2d_inChannels_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const conv2d_outChannels_input = document.getElementById("conv2d-outChannels-parameter")
      conv2d_outChannels_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("conv2d-outChannels-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "outChannels") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      conv2d_outChannels_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      //special
      const special_width_input = document.getElementById("special-width-parameter")
      special_width_input.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_changed_parameters_layer_id)
        const new_value = document.getElementById("special-width-parameter").value

        for (i in parameters) {
          if (parameters[i][0] == "width") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_changed_parameters_layer_id)
            break
          }
        }
      })
      special_width_input.addEventListener("input", () => {
        setModelView("irrelevant")
        last_changed_parameters_layer_id = last_selected_node_id
      })

      const loss_type_selector = document.getElementById("loss-type-parameter")
      loss_type_selector.addEventListener("change", () => {
        setModelView("irrelevant")
        const parameters = getParametersFromNode(last_selected_node_id)
        const new_value = loss_type_selector.value

        for (i in parameters) {
          if (parameters[i][0] == "type") {
            parameters[i][1] = new_value
            joinUpdatedLayerParameters(parameters, last_selected_node_id)
            break
          }
        }
      })

      /* DRAG EVENT */
      /* Mouse and Touch Actions */
      let elements = document.getElementsByClassName("drag-drawflow")
      for (let i = 0; i < elements.length; i++) {
        elements[i].addEventListener("touchend", drop, false)
        elements[i].addEventListener("touchmove", positionMobile, false)
        elements[i].addEventListener("touchstart", drag, false)
      }
      let mobile_item_selec = ""
      let mobile_last_move = null
      function positionMobile(ev) {
        mobile_last_move = ev
      }
      function allowDrop(ev) {
        ev.preventDefault()
      }
      function drag(ev, layer) {
        switch (layer) {
          case "linear":
            layer_drag_offset_X = ev.clientX - 50 // Linear layer offset X coord
            layer_drag_offset_Y = ev.clientY - 97 // Linear layer offset Y coord
            break
          case "relu":
            layer_drag_offset_X = ev.clientX - 50 // Relu layer offset X coord
            layer_drag_offset_Y = ev.clientY - 163 // Relu layer offset Y coord
            break
          case "pooling":
            layer_drag_offset_X = ev.clientX - 50 // Pooling layer offset X coord
            layer_drag_offset_Y = ev.clientY - 229 // Pooling layer offset Y coord
            break
          case "layernorm":
            layer_drag_offset_X = ev.clientX - 50 // LayerNorm layer offset X coord
            layer_drag_offset_Y = ev.clientY - 295 // LayerNorm layer offset Y coord
            break
          case "conv2d":
            layer_drag_offset_X = ev.clientX - 50 // Conv2D layer offset X coord
            layer_drag_offset_Y = ev.clientY - 361 // Conv2D layer offset Y coord
            break
          default:
            throw "Unreachable"
        }

        if (ev.type === "touchstart") {
          mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute("data-node")
        } else {
          ev.dataTransfer.setData("node", ev.target.getAttribute("data-node"))
        }
      }
      function drop(ev) {
        if (ev.type === "touchend") {
          const parentdrawflow = document
            .elementFromPoint(mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY)
            .closest("#drawflow")
          if (parentdrawflow != null) {
            addNodeToConstructor(
              mobile_item_selec,
              mobile_last_move.touches[0].clientX,
              mobile_last_move.touches[0].clientY,
            )
          }
          mobile_item_selec = ""
        } else {
          ev.preventDefault()
          const data = ev.dataTransfer.getData("node")
          addNodeToConstructor(data, ev.clientX, ev.clientY)
        }
      }

      function getParametersFromNode(id) {
        const layer_parameters = editor.getNodeFromId(id).data.Parameters
        const splited_parameters = layer_parameters.split(";")
        let parameters_array = []

        for (i in splited_parameters) {
          parameters_array.push(splited_parameters[i].split("="))
        }
        return parameters_array
      }

      function joinUpdatedLayerParameters(new_parameters, id) {
        let temp_array = []
        let new_parameters_string = null
        const dbid = editor.getNodeFromId(id).data.DBID
        const connections = editor.getNodeFromId(id).data.Connections

        let parameters_to_send = {
          id: dbid,
          parameters: null,
        }

        for (i in new_parameters) {
          temp_array.push(new_parameters[i].join("="))
        }
        new_parameters_string = temp_array.join(";")
        parameters_to_send["parameters"] = new_parameters_string
        console.log(parameters_to_send)

        updateLayerParameter(parameters_to_send).then(response => {
          if (response.ok) {
            editor.updateNodeDataFromId(id, {
              DBID: dbid,
              Connections: connections,
              Parameters: new_parameters_string,
            })
          } else {
            errorNotification("Failed to update parameters.\n Server is not responding now.")
            hideLayerInfo(id)
            showLayerInfo(id)
          }
        })
      }

      async function addNodeToConstructor(name, pos_x, pos_y) {
        if (editor.editor_mode === "fixed") return false

        pos_x =
          pos_x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) -
          editor.precanvas.getBoundingClientRect().x *
            (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom))
        pos_y =
          pos_y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) -
          editor.precanvas.getBoundingClientRect().y *
            (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom))

        pos_x -= layer_drag_offset_X
        pos_y -= layer_drag_offset_Y

        const empty_data = {}
        switch (name) {
          case "linear":
            const linear = `<div class="layer"><i class="fab moduleA"></i> Linear</div>`
            editor.addNode("linear", 1, 1, pos_x, pos_y, "linear", empty_data, linear)
            break
          case "relu":
            const relu = `<div class="layer"><i class="fab moduleA"></i> ReLU</div>`
            editor.addNode("relu", 1, 1, pos_x, pos_y, "relu", empty_data, relu)
            break
          case "pooling":
            const pooling = `<div class="layer"><i class="fab moduleA"></i> Pooling</div>`
            editor.addNode("pooling", 1, 1, pos_x, pos_y, "pooling", empty_data, pooling)
            break
          case "layernorm":
            const layernorm = `<div class="layer"><i class="fab moduleA"></i> LayerNorm</div>`
            editor.addNode("layernorm", 1, 1, pos_x, pos_y, "layernorm", empty_data, layernorm)
            break
          case "conv2d":
            const conv2d = `<div class="layer"><i class="fab moduleA"></i> Conv2D</div>`
            editor.addNode("conv2d", 1, 1, pos_x, pos_y, "conv2d", empty_data, conv2d)
            break
          case "data":
            const data = '<div class="title-box"><i class="fas fa-file-signature"></i> Data </div>'
            editor.addNode("data", 0, 1, pos_x, pos_y, "special", empty_data, data)
            break
          case "output":
            const output = '<div class="title-box"><i class="fas fa-file-signature"></i> Output </div>'
            editor.addNode("output", 1, 0, pos_x, pos_y, "special", empty_data, output)
            break
          case "target":
            const target = '<div class="title-box"><i class="fas fa-file-signature"></i> Target </div>'
            editor.addNode("target", 0, 1, pos_x, pos_y, "special", empty_data, target)
            break
          case "loss":
            const loss = '<div class="title-box"><i class="fas fa-file-signature"></i> Loss </div>'
            editor.addNode("loss", 1, 0, pos_x, pos_y, "special", empty_data, loss)
            break
          default:
            throw "Unreachable"
        }
      }

      let transform = ""
      function showpopup(e) {
        e.target.closest(".drawflow-node").style.zIndex = "9999"
        e.target.children[0].style.display = "block"

        transform = editor.precanvas.style.transform
        editor.precanvas.style.transform = ""
        editor.precanvas.style.left = editor.canvas_x + "px"
        editor.precanvas.style.top = editor.canvas_y + "px"

        editor.editor_mode = "fixed"
      }

      function closemodal(e) {
        e.target.closest(".drawflow-node").style.zIndex = "2"
        e.target.parentElement.parentElement.style.display = "none"
        editor.precanvas.style.transform = transform
        editor.precanvas.style.left = "0px"
        editor.precanvas.style.top = "0px"
        editor.editor_mode = "edit"
      }

      function changeMode(option) {
        //console.log(lock.id);
        if (option == "lock") {
          lock.style.display = "none"
          unlock.style.display = "block"
        } else {
          lock.style.display = "block"
          unlock.style.display = "none"
        }
      }
    </script>

    <!--Метрики-->
    <script>
      async function getMetricsFromServer() {
        let metricsPage = document.querySelector("#metrics")
        const response = await fetch(`http://${py_server_address}/get_plots/${user_id}/${model_id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            label: "default",
          }),
        })
        if (!response.ok) {
          console.error("Ошибка при получении метрик:", response.statusText)
          return
        }
        const blob = await response.blob()
        const imageUrl = URL.createObjectURL(blob)
        metricsPage.innerHTML = ""
        const imageElement = document.createElement("img")
        imageElement.src = imageUrl
        // Добавляем стили для центрирования изображения
        imageElement.style.display = "block"
        imageElement.style.margin = "auto"
        metricsPage.appendChild(imageElement)
        URL.revokeObjectURL(imageUrl)
      }
    </script>
    <!--Метрики-->

    <!--Заглушки-->
    <script>
      function getLayerInfoFromDB(id) {
        //todo
        //взаимодействие с сервером, бд
      }
      function exportNN(NNdata) {
        //todo
      }
      function signOut() {
        localStorage.clear()
      }
      async function openNNInConstructor(NNdata) {
        // Load drawflow data from saved model to CURRENT model
        const saved_id = NNdata.value
        response = await fetch(`http://${py_server_address}/${user_id}/${saved_id}`, {mode: "cors"})
        if (!response.ok) {
          console.error(`Failed to fetch model data for id = ${saved_id}`)
          return
        }
        raw = await response.json()
        if (!raw) {
          console.error(`Model ${saved_id} was loaded from db, but doesn't have any data in it`)
        }

        openConstructior()

        const feedback = (icon, title, text) => {
          Swal.fire({
            position: "top-end",
            icon: icon,
            title: title,
            text: text,
            showConfirmButton: false,
            timer: 1500,
          })
        }

        clearAlert(async result => {
          if (!result.isConfirmed) {
            feedback("error", "Cancelled", "Model not loaded")
            return
          }
          // Copy the rest of the data in database to the current model
          const response = await sendJson(
            {},
            `http://${py_server_address}/${user_id}/${saved_id}/copy/${model_id}`,
            "PUT",
          )
          if (!response.ok) {
            feedback("error", "Request failed", "You can try again, but it's unlikely to work...")
            return
          }
          hideResult()
          onTrainShowPredict(false)
          editor.import(raw, false)
          saveCanvasToLocalStorage(editor)
          // TODO: error handling
          feedback("success", "Done", "Model loaded successfully")
        })
      }
      async function saveNN(name) {
        let new_model_id = await saveNNhtmlToDB(name)
        if (new_model_id) addModelBlock(name, new_model_id)
        return new_model_id !== null
      }
      async function saveNNhtmlToDB(name) {
        // Copy current model
        let response = await sendJson({}, `http://${py_server_address}/${user_id}/${model_id}/copy`, "PUT")
        if (!response.ok) {
          console.error(`Failed to add new model for ${user_id}`)
          return null
        }

        // Get its fresh ID
        const new_model_id = (await response.json()).model_id
        const json = JSON.stringify(editor.export())

        // Save drawflow data to the copy
        response = await sendJson(
          {name: name, raw: json},
          `http://${py_server_address}/${user_id}/${new_model_id}`,
          "PUT",
        )
        if (!response.ok) {
          console.error(`Failed to update model with id = ${new_model_id}`)
          return null
        }

        return new_model_id
      }
      function createNewNN() {
        clearCanvas()
        openConstructior()
      }
    </script>

    <!--JSON requests handling-->
    <script>
      const predict_button = document.getElementById("predict-button")
      predict_button.onclick = () => {
        predict_button.value = null
      }

      predict_button.addEventListener("input", predictRequest)

      function buildJsonFormData(form) {
        const jsonFormData = {}
        for (const pair of new FormData(form)) {
          jsonFormData[pair[0]] = Number(pair[1])
        }
        return jsonFormData
      }

      async function deleteModel(id) {
        const response = await fetch(`http://${py_server_address}/${user_id}/${id}`, {
          method: "DELETE",
          mode: "cors",
        })
        return response
      }

      async function getModelList() {
        const response = await fetch(`http://${py_server_address}/models/${user_id}`, {mode: "cors"})
        if (!response.ok) {
          console.error(`Failed to fetch models for current user: ${await response.json()}`)
          return []
        }
        return await response.json()
      }
    </script>

    <!-- JS scripts -->
    <script>
      console.log(`current user id: ${user_id}`)
      // Функция, позволяющая вызывать другю функцию через ms времени
      const delay = async ms => await new Promise(resolve => setTimeout(resolve, ms))

      // Do something every time this page is loaded
      onReload()
      async function onReload() {
        const models = await getModelList()
        for (const i in models) addModelBlock(models[i].name, models[i].id)
      }
    </script>

    <!--Общее взаимодействие html и js-->
    <script>
      function showMode(event) {
        let all = document.querySelectorAll(".menu ul li")
        let modes = document.querySelectorAll("div.home, div.constructor, div.metrics")
        for (let i = 0; i < all.length; i++) {
          all[i].classList.remove("selected")
          modes[i].style.display = "none"
        }
        event.target.classList.add("selected")
        document.getElementById(event.target.id.split("-")[1]).style.display = "flex"
      }
      function showProfile() {
        let prf = document.getElementById("profile")
        if (prf.style.display == "block") prf.style.display = "none"
        else prf.style.display = "block"
      }
    </script>

    <!--Домашний экран-->
    <script>
      function addModelBlock(name, nn_id) {
        if (name == "") name = "New Neural Network"
        let container = document.getElementById("nn-container")
        let str = `'            <div class="nn-block">
                <data id="id" value="${nn_id}"></data>
                <span class="text-wrapper"> ${name} </span>
                <label class="button-wrapper">
                    Open
                    <input type="button" onclick="openNNInConstructor(this.parentElement.parentElement.children[0])"> <!--передает id nn-->
                </label>
                <label class="button-wrapper">
                    Export
                    <input type="button" onclick="exportNN()">
                </label>
                <label class="button-wrapper">
                    Delete
                    <input type="button" class="profile-check" onclick="deleteModelBlock(this.parentElement.parentElement)">
                </label>
            </div>'`
        container.innerHTML += str.substring(1, str.length - 1)
      }
      function deleteModelBlock(elem) {
        Swal.fire({
          title: "Delete the network?",
          text: "You won't be able to revert this!",
          icon: "warning",
          showCancelButton: true,
          confirmButtonColor: "#3085d6",
          cancelButtonColor: "#d33",
          confirmButtonText: "Yes, delete it!",
          allowOutsideClick: () => !Swal.isLoading(),
        }).then(async result => {
          if (!result.isConfirmed) return
          //delete nn from db
          const id = elem.children[0].value
          const response = await deleteModel(id)
          //verify deletion
          if (!response.ok) {
            console.error(`Failed to delete model with id ${id}: ${await response.json()}`)
            Swal.fire({
              position: "top-end",
              icon: "error",
              title: "Failed",
              text: "Unable to delete, you can try again, but its unlikely to work...",
              showConfirmButton: false,
              timer: 1500,
            })
            return
          }
          elem.remove()
          Swal.fire({
            position: "top-end",
            icon: "success",
            title: "Deleted!",
            text: "Neural network has been deleted",
            showConfirmButton: false,
            timer: 1500,
          })
        })
      }
      function uploadModel() {
        addModelBlock()
      }
      function changeNNShowMode() {}
      function openConstructior() {
        const all = document.querySelectorAll(".menu ul li")
        const modes = document.querySelectorAll("div.home, div.constructor, div.metrics")
        for (let i = 0; i < all.length; i++) {
          all[i].classList.remove("selected")
          modes[i].style.display = "none"
        }
        const constructor = document.getElementById("constructor")
        constructor.classList.add("selected")
        constructor.style.display = "flex"
      }
    </script>

    <!--Конструктор-->
    <script>
      // Notifications
      const buildSuccessful = () => {
        Swal.fire({
          position: "top-end",
          icon: "success",
          title: "Neural network has been built",
          showConfirmButton: false,
          timer: 1500,
        })
      }
      const buildUnsuccessful = () => {
        Swal.fire({
          position: "top-end",
          icon: "error",
          title: "Failed to build neural network",
          showConfirmButton: false,
          timer: 1500,
        })
      }
      const showBuildNotification = build_status => {
        build_status ? buildSuccessful() : buildUnsuccessful()
      }
      const data_upload = document.getElementById("dataset-upload-button")
      data_upload.onclick = () => {
        data_upload.value = null
      }
      data_upload.addEventListener("change", uploadRequest)

      function onTrainShowPredict(training_successful) {
        const predict_button = document.getElementById("predict-button")
        hideResult() // hide result when new training results arrive
        if (training_successful) {
          predict_button.removeAttribute("disabled")
          predict_button.parentElement.removeAttribute("disabled")
        } else {
          predict_button.setAttribute("disabled", "")
          predict_button.parentElement.setAttribute("disabled", "")
        }
      }
      function onPredictShowResult(res) {
        document.getElementById("res-value-out").innerHTML = res[0]
        document.getElementById("predict-result-wrapper").style.textAlign = "center"
        document.getElementById("predict-result-wrapper").style.display = "block"
      }

      // Array of connections with written id (input selection)
      let pathsWithWrittenID = []
      function writeIdOnConnections(id) {
        const connections = editor.getNodeFromId(id).data.Connections

        for (let connection of connections) {
          const from_layer_drawflow_id = connection.split(";")[1]
          const htmlConnection = document.querySelector(
            `.connection.node_in_node-${id}.node_out_node-${from_layer_drawflow_id}.output_1.input_1`,
          )
          const tmp = addLabelText(htmlConnection, connection.split(";")[0]) // Writes id on connection
          pathsWithWrittenID.push(tmp)
        }
        is_id_on_paths = true
      }

      // Remove id written on connection
      function deleteIdOnConnections() {
        for (let path of pathsWithWrittenID) {
          try {
            path.setAttribute("display", "none")
          } catch (e) {
            console.error(e)
          }
        }
        pathsWithWrittenID = []
        is_id_on_paths = false
      }

      function getSortableInputList(layer) {
        switch (layer.class) {
          case "linear":
            return document.querySelector("#linear-inputs-sortable-list")
          case "relu":
            return document.querySelector("#relu-inputs-sortable-list")
          case "pooling":
            return document.querySelector("#pooling-inputs-sortable-list")
          case "layernorm":
            return document.querySelector("#layernorm-inputs-sortable-list")
          case "conv2d":
            return document.querySelector("#conv2d-inputs-sortable-list")
          case "special":
            if (layer.name == "Loss") {
              return document.querySelector("#loss-inputs-sortable-list")
            }
            return document.querySelector("#special-inputs-sortable-list")
        }
      }

      function hideResult() {
        document.getElementById("predict-result-wrapper").style.display = "none"
      }

      function matchConnectionsAfterSelection(new_input_order) {
        let newConnections = []
        let connections = editor.getNodeFromId(input_selection_layer_id).data.Connections
        for (let input of new_input_order) {
          for (let connection of connections) {
            if (input == connection.split(";")[0]) {
              newConnections.push(connection)
            }
          }
        }
        let new_inputs_object = {
          new_parents: new_input_order,
          layer_id: input_selection_layer_dbid,
        }
        updateParentOrder(new_inputs_object).then(response => {
          if (response.ok) {
            editor.updateNodeDataFromId(input_selection_layer_id, {
              DBID: input_selection_layer_dbid,
              Connections: newConnections,
              Parameters: editor.getNodeFromId(input_selection_layer_id).data.Parameters,
            })
          } else {
            errorNotification("Failed to update input order.\n Server is not responding now.")
          }
        })
      }

      function showLayerInfo(id) {
        hideLayerInfo()
        // id format "node-<id>"
        let correct_id = id
        if (id.includes("node")) {
          correct_id = id.split("-")[1]
        }
        const node = editor.getNodeFromId(correct_id)
        const connections = editor.getNodeFromId(correct_id).data.Connections
        const layer_dbid = editor.getNodeFromId(correct_id).data.DBID
        input_selection_layer_id = correct_id
        input_selection_layer_dbid = layer_dbid

        // Input selection
        writeIdOnConnections(input_selection_layer_id)

        let sortable_list = getSortableInputList(node)
        let child = sortable_list.lastElementChild

        while (child) {
          sortable_list.removeChild(child)
          child = sortable_list.lastElementChild
        }
        let input_list = document.getElementsByClassName("layer-input-list")
        for (let elem of input_list) elem.style.display = "none"
        let counter = 0
        for (let connection of connections) {
          for (let elem of input_list) elem.style.display = "block"
          let new_element = document.createElement("LI")
          new_element.classList.add("button-wrapper")
          counter += 1
          const text_for_new_element = document.createTextNode(connection.split(";")[0])
          new_element.appendChild(text_for_new_element)
          sortable_list.appendChild(new_element)
        }

        let new_input_order = []
        new Sortable(sortable_list, {
          animation: 150,
          ghostClass: "sortable-ghost",
          onEnd: function (event) {
            new_input_order = []
            for (let i in sortable_list.childNodes) {
              try {
                if (sortable_list.childNodes[i].textContent.length > 0) {
                  console.log(sortable_list.childNodes[i].textContent)
                  new_input_order.push(Number(sortable_list.childNodes[i].textContent))
                }
              } catch (e) {
                continue
              }
            }
            matchConnectionsAfterSelection(new_input_order)
          },
        })

        document.getElementById("layer-data").style.display = "block"
        setupLayerParameters(node, correct_id)
      }

      function setupLayerParameters(layer, layer_id) {
        let layer_parameters = getParametersFromNode(layer_id)

        switch (layer.class) {
          case "linear":
            document.querySelector("#linear-layer-parameters").style.display = "block"

            for (i in layer_parameters) {
              switch (layer_parameters[i][0]) {
                case "bias":
                  document.querySelector("#bias-parameter").value = layer_parameters[i][1] == "1"
                  break
                case "inFeatures":
                  document.querySelector("#linear-inFeatures-parameter").value = layer_parameters[i][1]
                  break
                case "outFeatures":
                  document.querySelector("#linear-outFeatures-parameter").value = layer_parameters[i][1]
                  break
              }
            }
            break

          case "special":
            if (layer.name == "Loss") {
              document.querySelector("#loss-layer-parameters").style.display = "block"
              for (i in layer_parameters) {
                switch (layer_parameters[i][0]) {
                  case "width":
                    document.querySelector("#loss-width-parameter").value = layer_parameters[i][1]
                    break
                  case "type":
                    document.querySelector("#loss-type-parameter").value = layer_parameters[i][1]
                    break
                }
              }
            } else {
              document.querySelector("#special-layer-parameters").style.display = "block"
              for (i in layer_parameters) {
                switch (layer_parameters[i][0]) {
                  case "width":
                    document.querySelector("#special-width-parameter").value = layer_parameters[i][1]
                    break
                  case "type":
                    document.querySelector("#loss-type-parameter").value = layer_parameters[i][1]
                    break
                }
              }
            }
            break

          case "relu":
            document.querySelector("#relu-layer-parameters").style.display = "block"
            for (i in layer_parameters) {
              if (layer_parameters[i][0] == "width") {
                document.querySelector("#relu-width-parameter").value = layer_parameters[i][1]
              }
            }
            break

          case "pooling":
            document.querySelector("#pooling-layer-parameters").style.display = "block"
            for (i in layer_parameters) {
              // Not given
            }
            break

          case "layernorm":
            document.querySelector("#layernorm-layer-parameters").style.display = "block"
            for (i in layer_parameters) {
              if (layer_parameters[i][0] == "axis") {
                document.querySelector("#layernorm-axis-parameter").value = layer_parameters[i][1]
              }
            }
            break

          case "conv2d":
            document.querySelector("#conv2d-layer-parameters").style.display = "block"
            for (i in layer_parameters) {
              switch (layer_parameters[i][0]) {
                case "kernelSize":
                  document.querySelector("#conv2d-KernelSize-parameter").value = layer_parameters[i][1]
                  break
                case "inChannels":
                  document.querySelector("#conv2d-inChannels-parameter").value = layer_parameters[i][1]
                  break
                case "outChannels":
                  document.querySelector("#conv2d-outChannels-parameter").value = layer_parameters[i][1]
                  break
              }
            }
            break
        }
      }

      function hideLayerInfo() {
        document.getElementById("layer-data").style.display = "none"

        document.querySelector("#linear-layer-parameters").style.display = "none"
        document.querySelector("#special-layer-parameters").style.display = "none"
        document.querySelector("#relu-layer-parameters").style.display = "none"
        document.querySelector("#pooling-layer-parameters").style.display = "none"
        document.querySelector("#layernorm-layer-parameters").style.display = "none"
        document.querySelector("#conv2d-layer-parameters").style.display = "none"
        document.querySelector("#loss-layer-parameters").style.display = "none"

        if (is_id_on_paths) {
          deleteIdOnConnections()
        }
      }

      function addLabelText(path, labelText) {
        try {
          const newid = [path.classList].join().replace(/\s/g, "")
          path.childNodes[0].id = newid
          let textElem = document.createElementNS(path.namespaceURI, "text")
          let textElemPath = document.createElementNS(path.namespaceURI, "textPath")
          textElemPath.setAttribute("href", `#${newid}`)
          textElemPath.setAttribute("text-anchor", "middle")
          textElemPath.setAttribute("startOffset", "50%")
          textElemPath.setAttribute("style", "font-size:30px")
          textElemPath.textContent = labelText
          textElemPath.classList.add("label-text")
          textElem.appendChild(textElemPath)
          path.appendChild(textElem)
          return textElemPath
        } catch (e) {}
      }

      function save() {
        Swal.fire({
          title: "Enter the name of your neural network",
          input: "text",
          inputAttributes: {
            autocapitalize: "off",
          },
          showCancelButton: true,
          confirmButtonText: "Save",
          showLoaderOnConfirm: true,
          preConfirm: async name => {
            return await saveNN(name) //еще нужно проверить корректность name
          },
          allowOutsideClick: () => !Swal.isLoading(),
        }).then(result => {
          if (result.isConfirmed) {
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Neural network has been saved",
              showConfirmButton: false,
              timer: 1500,
            })
          }
        })
      }

      let modelIsUpToDate = "irrelevant"
      function setModelView(state) {
        modelIsUpToDate = state
        let nodes = document.getElementsByClassName("drawflow-node")
        let connections = document.getElementsByClassName("main-path")

        if (state == "success") {
          for (let node of nodes) {
            if (!node.classList.contains("predict-success")) node.classList.add("predict-success")
            if (node.classList.contains("predict-error")) node.classList.remove("predict-error")
          }
          for (let connection of connections) {
            if (!connection.classList.contains("connection-predict-success"))
              connection.classList.add("connection-predict-success")
            if (connection.classList.contains("connection-predict-error"))
              connection.classList.remove("connection-predict-error")
          }
        } else if (state == "error") {
          for (let node of nodes) {
            if (node.classList.contains("predict-up-to-success")) node.classList.remove("predict-success")
            if (!node.classList.contains("predict-error")) node.classList.add("predict-error")
          }
          for (let connection of connections) {
            if (connection.classList.contains("connection-predict-success"))
              connection.classList.remove("connection-predict-success")
            if (!connection.classList.contains("connection-predict-error"))
              connection.classList.add("connection-predict-error")
          }
        } else {
          for (let node of nodes) {
            if (node.classList.contains("predict-error")) node.classList.remove("predict-error")
            if (node.classList.contains("predict-success")) node.classList.remove("predict-success")
          }
          for (let connection of connections) {
            if (connection.classList.contains("connection-predict-error"))
              connection.classList.remove("connection-predict-error")
            if (connection.classList.contains("connection-predict-success"))
              connection.classList.remove("connection-predict-success")
          }
        }
      }

      function updateConnectionsInLayers(deleted_id) {
        let nodes = document.getElementsByClassName("drawflow-node")
        for (let i of nodes) {
          const data1 = editor.getNodeFromId(i.id.split("-")[1]).data
          let updatedConnections = []
          for (let connection of data1.Connections) {
            if (connection.split(";")[1] == deleted_id) {
              continue
            }
            updatedConnections.unshift(connection)
          }
          editor.updateNodeDataFromId(i.id.split("-")[1], {
            DBID: data1.DBID,
            Connections: updatedConnections,
            Parameters: data1.Parameters,
          })
        }
      }
    </script>

    <!--Терминал-->
    <script></script>

    <!--Метрика-->
    <script></script>
  </body>
</html>
